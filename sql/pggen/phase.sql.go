// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertPhaseStatusTimestampSQL = `INSERT INTO phase_status_timestamps (
    run_id,
    phase,
    status,
    timestamp
) VALUES (
    $1,
    $2,
    $3,
    $4
);`

type InsertPhaseStatusTimestampParams struct {
	RunID     pgtype.Text
	Phase     pgtype.Text
	Status    pgtype.Text
	Timestamp pgtype.Timestamptz
}

// InsertPhaseStatusTimestamp implements Querier.InsertPhaseStatusTimestamp.
func (q *DBQuerier) InsertPhaseStatusTimestamp(ctx context.Context, params InsertPhaseStatusTimestampParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertPhaseStatusTimestamp")
	cmdTag, err := q.conn.Exec(ctx, insertPhaseStatusTimestampSQL, params.RunID, params.Phase, params.Status, params.Timestamp)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertPhaseStatusTimestamp: %w", err)
	}
	return cmdTag, err
}

// InsertPhaseStatusTimestampBatch implements Querier.InsertPhaseStatusTimestampBatch.
func (q *DBQuerier) InsertPhaseStatusTimestampBatch(batch genericBatch, params InsertPhaseStatusTimestampParams) {
	batch.Queue(insertPhaseStatusTimestampSQL, params.RunID, params.Phase, params.Status, params.Timestamp)
}

// InsertPhaseStatusTimestampScan implements Querier.InsertPhaseStatusTimestampScan.
func (q *DBQuerier) InsertPhaseStatusTimestampScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertPhaseStatusTimestampBatch: %w", err)
	}
	return cmdTag, err
}

const insertLogChunkSQL = `INSERT INTO logs (
    run_id,
    phase,
    chunk
) VALUES (
    $1,
    $2,
    $3
)
;`

type InsertLogChunkParams struct {
	RunID pgtype.Text
	Phase pgtype.Text
	Chunk []byte
}

// InsertLogChunk implements Querier.InsertLogChunk.
func (q *DBQuerier) InsertLogChunk(ctx context.Context, params InsertLogChunkParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertLogChunk")
	cmdTag, err := q.conn.Exec(ctx, insertLogChunkSQL, params.RunID, params.Phase, params.Chunk)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertLogChunk: %w", err)
	}
	return cmdTag, err
}

// InsertLogChunkBatch implements Querier.InsertLogChunkBatch.
func (q *DBQuerier) InsertLogChunkBatch(batch genericBatch, params InsertLogChunkParams) {
	batch.Queue(insertLogChunkSQL, params.RunID, params.Phase, params.Chunk)
}

// InsertLogChunkScan implements Querier.InsertLogChunkScan.
func (q *DBQuerier) InsertLogChunkScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertLogChunkBatch: %w", err)
	}
	return cmdTag, err
}

const findLogChunksSQL = `SELECT
    substring(string_agg(chunk, '') FROM $1 FOR $2)
FROM (
    SELECT run_id, phase, chunk
    FROM logs
    WHERE run_id = $3
    AND   phase  = $4
    ORDER BY chunk_id
) c
GROUP BY run_id, phase
;`

type FindLogChunksParams struct {
	Offset int
	Limit  int
	RunID  pgtype.Text
	Phase  pgtype.Text
}

// FindLogChunks implements Querier.FindLogChunks.
func (q *DBQuerier) FindLogChunks(ctx context.Context, params FindLogChunksParams) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindLogChunks")
	row := q.conn.QueryRow(ctx, findLogChunksSQL, params.Offset, params.Limit, params.RunID, params.Phase)
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query FindLogChunks: %w", err)
	}
	return item, nil
}

// FindLogChunksBatch implements Querier.FindLogChunksBatch.
func (q *DBQuerier) FindLogChunksBatch(batch genericBatch, params FindLogChunksParams) {
	batch.Queue(findLogChunksSQL, params.Offset, params.Limit, params.RunID, params.Phase)
}

// FindLogChunksScan implements Querier.FindLogChunksScan.
func (q *DBQuerier) FindLogChunksScan(results pgx.BatchResults) ([]byte, error) {
	row := results.QueryRow()
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan FindLogChunksBatch row: %w", err)
	}
	return item, nil
}
